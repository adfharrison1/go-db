/**
 * Clean type-safe usage examples for the go-db TypeScript SDK
 * Following the elegant approach with user-defined schemas
 */

import { createClient } from '../index';

// 1) Define your application's data types
type User = {
  _id?: string; // Auto-generated by database
  name: string;
  age: number;
  email: string;
  tags?: string[];
  profile?: {
    bio: string;
    location: string;
  };
  active: boolean;
};

type Order = {
  _id?: string; // Auto-generated by database
  userId: string;
  total: number;
  status: 'pending' | 'completed' | 'cancelled';
  items: Array<{
    productId: string;
    quantity: number;
    price: number;
  }>;
  createdAt: string;
};

type Product = {
  _id?: string; // Auto-generated by database
  title: string;
  price: number;
  category: string;
  inStock: boolean;
  metadata: {
    description: string;
    weight: number;
    dimensions: {
      length: number;
      width: number;
      height: number;
    };
  };
};

// 2) Define your schema (types only; no runtime cost)
type MySchema = {
  users: User;
  orders: Order;
  products: Product;
};

// 3) Create a type-safe client
const db = createClient<MySchema>({
  baseURL: 'http://localhost:8080',
  timeout: 30000,
});

// Alternative: direct instantiation (if needed)
// const directClient = new GoDBClient<MySchema>({ baseURL: 'http://localhost:8080' });

async function demonstrateTypeSafeAPI() {
  console.log('üéØ Demonstrating Type-Safe go-db SDK');

  try {
    // ===== 1. Type-safe document insertion =====
    console.log('\nüìù Type-safe insertion...');

    // TypeScript enforces the correct structure and types
    const newUser = await db.insert('users', {
      // Note: 'id' is omitted because it's auto-generated as '_id'
      name: 'John Doe', // ‚úÖ Must be string
      age: 30, // ‚úÖ Must be number
      email: 'john@example.com', // ‚úÖ Must be string
      tags: ['developer', 'typescript'], // ‚úÖ Optional string array
      profile: {
        // ‚úÖ Optional nested object
        bio: 'Software developer',
        location: 'San Francisco',
      },
      active: true, // ‚úÖ Must be boolean
    });

    console.log('Created user:', newUser);
    // TypeScript knows newUser is of type User & { _id: string }

    // ===== 2. Type-safe document retrieval =====
    console.log('\nüîç Type-safe retrieval...');

    const user = await db.getById('users', newUser._id!);
    if (user) {
      console.log(`Found user: ${user.name} (${user.email})`);
      // TypeScript knows user.name is string, user.age is number, etc.
    }

    // ===== 3. Type-safe queries with filters =====
    console.log('\nüìä Type-safe queries...');

    const activeUsers = await db.find('users', {
      where: {
        active: true, // ‚úÖ TypeScript knows this should be boolean
        age: 25, // ‚úÖ TypeScript knows this should be number
      },
      limit: 10,
    });

    console.log(`Found ${activeUsers.length} active users`);
    activeUsers.forEach((u) => {
      console.log(`- ${u.name} (age: ${u.age})`); // ‚úÖ Full type safety
    });

    // ===== 4. Type-safe field selection =====
    console.log('\nüéØ Type-safe field selection...');

    const slimUsers = await db.find('users', {
      select: ['name', 'email'] as const, // ‚úÖ Must be valid field names
      limit: 5,
    });

    // TypeScript knows slimUsers is Array<Pick<User, 'name' | 'email'>>
    slimUsers.forEach((user) => {
      console.log(`${user.name}: ${user.email}`);
      // user.age would cause TypeScript error - not selected!
    });

    // ===== 5. Type-safe updates =====
    console.log('\n‚úèÔ∏è Type-safe updates...');

    const updatedUser = await db.updateById('users', newUser._id!, {
      age: 31, // ‚úÖ TypeScript knows this should be number
      profile: {
        // ‚úÖ TypeScript knows this should match profile structure
        bio: 'Senior developer',
        location: 'San Francisco',
      },
    });

    console.log('Updated user:', updatedUser);

    // ===== 6. Type-safe product operations =====
    console.log('\nüõçÔ∏è Type-safe product operations...');

    const product = await db.insert('products', {
      title: 'TypeScript SDK', // ‚úÖ Must be string
      price: 99.99, // ‚úÖ Must be number
      category: 'software', // ‚úÖ Must be string
      inStock: true, // ‚úÖ Must be boolean
      metadata: {
        // ‚úÖ Must match metadata structure
        description: 'A type-safe SDK for go-db',
        weight: 0.1,
        dimensions: {
          length: 10,
          width: 5,
          height: 1,
        },
      },
    });

    console.log('Created product:', product);

    // ===== 7. Type-safe order operations =====
    console.log('\nüì¶ Type-safe order operations...');

    const order = await db.insert('orders', {
      userId: newUser._id!, // ‚úÖ Must be string
      total: 99.99, // ‚úÖ Must be number
      status: 'pending', // ‚úÖ Must be one of the allowed values
      items: [
        {
          // ‚úÖ Must be array of valid item objects
          productId: product._id!,
          quantity: 1,
          price: 99.99,
        },
      ],
      createdAt: new Date().toISOString(), // ‚úÖ Must be string
    });

    console.log('Created order:', order);

    // ===== 8. Type-safe collection name validation =====
    console.log('\nüîí Type-safe collection validation...');

    // These work because the collection names are in the schema
    await db.getIndexes('users'); // ‚úÖ TypeScript knows 'users' is valid
    await db.getIndexes('orders'); // ‚úÖ TypeScript knows 'orders' is valid
    await db.getIndexes('products'); // ‚úÖ TypeScript knows 'products' is valid

    // This would cause a TypeScript error:
    // await db.getIndexes('invalid_collection'); // ‚ùå TypeScript error!

    // ===== 9. Type-safe field name validation =====
    console.log('\nüîë Type-safe field validation...');

    // Create indexes on valid fields
    await db.createIndex('users', 'email'); // ‚úÖ TypeScript knows 'email' is valid
    await db.createIndex('products', 'category'); // ‚úÖ TypeScript knows 'category' is valid

    // This would cause a TypeScript error:
    // await db.createIndex('users', 'invalid_field'); // ‚ùå TypeScript error!

    // ===== 10. Complex queries =====
    console.log('\nüßÆ Complex type-safe queries...');

    const expensiveProducts = await db.find('products', {
      where: {
        price: 50, // ‚úÖ TypeScript knows this should be number
        inStock: true, // ‚úÖ TypeScript knows this should be boolean
        category: 'software', // ‚úÖ TypeScript knows this should be string
      },
      select: ['title', 'price', 'category'] as const,
      limit: 10,
    });

    console.log('Expensive products:', expensiveProducts);

    // ===== 11. Cleanup =====
    console.log('\nüßπ Cleanup...');

    await db.deleteById('users', newUser._id!);
    await db.deleteById('products', product._id!);
    await db.deleteById('orders', order._id!);

    console.log('‚úÖ All type-safe operations completed successfully!');
  } catch (error) {
    console.error('‚ùå Error in type-safe demo:', error);
  }
}

// Demonstrate error cases that TypeScript catches at compile time
// These examples show what TypeScript will catch:
/*
// ‚ùå Invalid collection name
await db.getById('invalid_collection', 'id');

// ‚ùå Invalid field in insert
await db.insert('users', {
  name: 'John',
  invalidField: 'value'  // TypeScript error!
});

// ‚ùå Wrong type for field
await db.insert('users', {
  name: 'John',
  age: 'thirty'  // TypeScript error - should be number!
});

// ‚ùå Invalid field in select
await db.find('users', {
  select: ['name', 'invalid_field']  // TypeScript error!
});

// ‚ùå Invalid field in where clause
await db.find('users', {
  where: {
    invalidField: 'value'  // TypeScript error!
  }
});

// ‚ùå Wrong type in where clause
await db.find('users', {
  where: {
    age: 'old'  // TypeScript error - should be number!
  }
});

// ‚ùå Invalid field for index
await db.createIndex('users', 'invalid_field');  // TypeScript error!
*/

// Export for testing
export { demonstrateTypeSafeAPI, MySchema };

// Run the demo
if (require.main === module) {
  demonstrateTypeSafeAPI().catch(console.error);
}
